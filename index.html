<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Trivia Night Cost Splitter</title>
    <meta property="og:title" content="Trivia Night Cost Splitter" />
    <meta property="og:description" content="Split your trivia night costs fairly with this easy-to-use tool." />
    <meta property="og:image" content="https://rageandqq.github.io/trivia-split/logo.JPG" />
    <meta property="og:url" content="https://rageandqq.github.io/trivia-split/index.html" />
    <meta property="og:type" content="website" />
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="root"></div>

    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>
    <script type="text/babel">
        const { useState, useMemo, useEffect } = React;

        const defaultMembers = ['Tony', 'Nav', 'Caleb', 'Jeff', 'Ingrid', 'Sameer'];

        // Function to shuffle an array
        const shuffleArray = (array) => {
            const newArray = [...array];
            for (let i = newArray.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [newArray[i], newArray[j]] = [newArray[j], newArray[i]];
            }
            return newArray;
        };


        function ChevronIcon({ isCollapsed }) {
            return (
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    width="24"
                    height="24"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className={`chevron-icon ${isCollapsed ? 'chevron-down' : 'chevron-up'}`}
                >
                    <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
            );
        }

        function XIcon() {
            return (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="x-icon">
                    <line x1="18" y1="6" x2="6" y2="18"></line>
                    <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
            );
        }
        
        function PlusIcon() {
            return (
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="plus-icon">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
            );
        }

        function SettingsIcon({ onClick }) {
            return (
                <button className="settings-icon-btn" onClick={onClick}>
                    <img src="gear.svg" alt="Settings Gear" className="settings-icon" />
                </button>
            );
        }

        function SettingsPopover({ taxRate, setTaxRate, tipRate, setTipRate, winnings, setWinnings, members, onClose, isOpen }) {
            if (!isOpen) return null;

            return (
                <div className={`settings-popover-overlay ${isOpen ? 'open' : ''}`} onClick={onClose}>
                    <div className="settings-popover" onClick={e => e.stopPropagation()}>
                        <div className="settings-popover-header">
                            <h2>Settings</h2>
                            <button className="close-popover-btn icon-button" onClick={onClose}><XIcon /></button>
                        </div>
                        <div className="settings-popover-content">
                            <div className="input-group">
                                <label>Tax Rate:</label>
                                <div className="input-with-suffix">
                                    <input type="number" inputmode="decimal" value={taxRate} onChange={e => setTaxRate(parseFloat(e.target.value) || 0)} />
                                    <span>%</span>
                                </div>
                            </div>
                            <div className="input-group">
                                <label>Tip Rate:</label>
                                <div className="input-with-suffix">
                                    <input type="number" inputmode="decimal" value={tipRate} onChange={e => setTipRate(parseFloat(e.target.value) || 0)} />
                                    <span>%</span>
                                </div>
                            </div>
                            <div className="input-group">
                                <label>Winnings:</label>
                                <div className="input-with-prefix">
                                    <span>$</span>
                                    <input type="number" inputmode="decimal" value={winnings} onChange={e => setWinnings(parseFloat(e.target.value) || 0)} disabled={members.length === 0} />
                                </div>
                            </div>
                            <div className="quick-add-winnings-buttons">
                                <button onClick={() => setWinnings(35)} disabled={members.length === 0}>1st ($35)</button>
                                <button onClick={() => setWinnings(25)} disabled={members.length === 0}>2nd ($25)</button>
                                <button onClick={() => setWinnings(15)} disabled={members.length === 0}>3rd ($15)</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        function CollapsibleSection({ title, children, initialCollapsed = true }) {
            const [isCollapsed, setIsCollapsed] = useState(initialCollapsed);

            return (
                <div className="collapsible-section">
                    <div className="section-header" onClick={() => setIsCollapsed(!isCollapsed)}>
                        <h2>{title}</h2>
                        <button className="toggle-btn">
                            <ChevronIcon isCollapsed={isCollapsed} />
                        </button>
                    </div>
                    {!isCollapsed && <div className="section-content">{children}</div>}
                </div>
            );
        }



        function SummarySection({ calculations }) {
            return (
                <div className="summary-section">
                    {calculations.map(member => (
                        <div key={member.name} className="summary-member">
                            <a href={`#${member.name}`}>{member.name}</a>
                            <span>${member.finalOwed.toFixed(2)}</span>
                        </div>
                    ))}
                </div>
            );
        }

        function App() {
            const [members, setMembers] = useState([]);

            useEffect(() => {
                const shuffledNames = shuffleArray(defaultMembers);
                const initialMembers = shuffledNames.map(name => ({ name, expenses: [] }));
                setMembers(initialMembers);
            }, []);
			
                        const [taxRate, setTaxRate] = useState(8.875);
                        const [tipRate, setTipRate] = useState(20);
                        const [winnings, setWinnings] = useState(35);
                        const [newMemberName, setNewMemberName] = useState("");
                        const [showSettingsPopover, setShowSettingsPopover] = useState(false); // State for settings popover
                        
                        const handleAddMember = () => {
                            if (newMemberName.trim() && !members.find(m => m.name === newMemberName.trim())) {
                                setMembers([...members, { name: newMemberName.trim(), expenses: [] }]);
                                setNewMemberName("");
                            }
                        };
            
                        const handleRemoveMember = (memberName) => {
                            setMembers(members.filter(m => m.name !== memberName));
                        };
            
                        const handleAddExpense = (memberName, amount) => {
                            const newMembers = members.map(member => {
                                if (member.name === memberName) {
                                    const newExpense = parseFloat(amount);
                                    if (!isNaN(newExpense) && newExpense > 0) {
                                        return { ...member, expenses: [...member.expenses, newExpense] };
                                    }
                                }
                                return member;
                            });
                            setMembers(newMembers);
                        };
            
                        const handleRemoveExpense = (memberName, expenseIndex) => {
                            const newMembers = members.map(member => {
                                if (member.name === memberName) {
                                    return { ...member, expenses: member.expenses.filter((_, i) => i !== expenseIndex) };
                                }
                                return member;
                            });
                            setMembers(newMembers);
                        };
            
                        const calculations = useMemo(() => {
                            let membersCalculations = members.map(member => {
                                const subtotal = member.expenses.reduce((acc, expense) => acc + expense, 0);
                                return {
                                    name: member.name,
                                    subtotal,
                                    tip: subtotal * (tipRate / 100),
                                    winningsApplied: 0, // Track winnings applied to this member
                                };
                            });
            
                            // Calculate preliminary owed (subtotal + tip) for distribution purposes
                            let membersForWinnings = membersCalculations.map(m => ({
                                ...m,
                                preliminaryOwed: m.subtotal + m.tip,
                            }));
            
                            let totalWinningsToDistribute = winnings;
                            let iterationCount = 0;
                            const MAX_ITERATIONS = members.length * 2; // Prevent infinite loops
            
                            while (totalWinningsToDistribute > 0 && iterationCount < MAX_ITERATIONS) {
                                iterationCount++;
                                let eligibleMembers = membersForWinnings.filter(m => m.preliminaryOwed - m.winningsApplied > 0);
            
                                if (eligibleMembers.length === 0) {
                                    break; // No more members can receive winnings
                                }
            
                                const sharePerEligibleMember = totalWinningsToDistribute / eligibleMembers.length;
                                let winningsDistributedInThisIteration = 0;
            
                                for (const member of eligibleMembers) {
                                    const canReceive = member.preliminaryOwed - member.winningsApplied;
                                    const amountToApply = Math.min(sharePerEligibleMember, canReceive);
            
                                    member.winningsApplied += amountToApply;
                                    winningsDistributedInThisIteration += amountToApply;
                                }
            
                                totalWinningsToDistribute -= winningsDistributedInThisIteration;
                                // If no winnings were distributed, or very little, break to prevent tiny remainder loops
                                if (winningsDistributedInThisIteration < 0.01 && totalWinningsToDistribute > 0) {
                                    // Distribute remaining winnings evenly among whoever can still receive
                                    const remainingEligible = membersForWinnings.filter(m => m.preliminaryOwed - m.winningsApplied > 0);
                                    if (remainingEligible.length > 0) {
                                        const finalShare = totalWinningsToDistribute / remainingEligible.length;
                                        for(const member of remainingEligible) {
                                            const canReceive = member.preliminaryOwed - member.winningsApplied;
                                            const amountToApply = Math.min(finalShare, canReceive);
                                            member.winningsApplied += amountToApply;
                                        }
                                    }
                                    totalWinningsToDistribute = 0; // All winnings accounted for
                                }
                            }
            
                            // Now, calculate the final values with the correct tax and final owed
                            return membersCalculations.map(originalMember => {
                                const distributedWinnings = membersForWinnings.find(m => m.name === originalMember.name).winningsApplied;
                                originalMember.winningsShare = distributedWinnings; // Update original object with final winnings share
            
                                const taxableAmount = Math.max(0, originalMember.subtotal - originalMember.winningsShare);
                                const tax = taxableAmount * (taxRate / 100);
            
                                const preWinningsTotal = originalMember.subtotal + tax + originalMember.tip;
                                const finalOwed = preWinningsTotal - originalMember.winningsShare;
            
                                return {
                                    ...originalMember,
                                    tax,
                                    preWinningsTotal,
                                    finalOwed: Math.max(0, finalOwed),
                                };
                            });
                        }, [members, taxRate, tipRate, winnings]);
            
            
                        return (
                            <div>
                            <div className="logo-container">
                                <img src="logo.JPG" alt="Trivia Night Logo" className="logo-image" />
                                <h1>Trivia Split</h1>
                                <SettingsIcon onClick={() => setShowSettingsPopover(true)} />
                            </div>
            
                                <CollapsibleSection title="Summary" initialCollapsed={false}>
                                    <SummarySection calculations={calculations} />
                                </CollapsibleSection>
            
                                <div className="members-container">
                                    <h2>Members</h2>
                                    {members.map(member => {
                                        const calculatedMember = calculations.find(c => c.name === member.name);
                                        return (
                                            <Member
                                                key={member.name}
                                                member={member}
                                                calculated={calculatedMember}
                                                onRemoveMember={handleRemoveMember}
                                                onAddExpense={handleAddExpense}
                                                onRemoveExpense={handleRemoveExpense}
                                            />
                                        );
                                    })}
                                </div>
            
                                <CollapsibleSection title="Manage Members">
                                    <div className="add-member">
                                        <div className="input-group input-group-responsive">
                                            <input
                                                type="text"
                                                value={newMemberName}
                                                onChange={e => setNewMemberName(e.target.value)}
                                                onKeyDown={e => e.key === 'Enter' && handleAddMember()}
                                                placeholder="Name"
                                            />
                                            <button onClick={handleAddMember} className="icon-button"><PlusIcon /></button>
                                        </div>
                                    </div>
                                </CollapsibleSection>
            
                                <SettingsPopover 
                                    isOpen={showSettingsPopover}
                                    onClose={() => setShowSettingsPopover(false)}
                                    taxRate={taxRate}
                                    setTaxRate={setTaxRate}
                                    tipRate={tipRate}
                                    setTipRate={setTipRate}
                                    winnings={winnings}
                                    setWinnings={setWinnings}
                                    members={members}
                                />
                            </div>
                        );
                    }
        function Member({ member, calculated, onRemoveMember, onAddExpense, onRemoveExpense }) {
            const [newExpense, setNewExpense] = useState("");
            const [isDetailsCollapsed, setIsDetailsCollapsed] = useState(true);

            const handleAddExpense = () => {
                if (newExpense.trim()) {
                    onAddExpense(member.name, newExpense);
                    setNewExpense("");
                }
            };
            
            const handleExpenseKeyDown = (e) => {
                if (e.key === 'Enter') {
                    handleAddExpense();
                }
            };

            return (
                <div id={member.name} className="member">
                    <div className="member-header">
                        <h3>{member.name}</h3>
                        <button className="remove-member-btn icon-button" onClick={() => onRemoveMember(member.name)}><XIcon /></button>
                    </div>

                    <div className="expenses">
                        <h4>Expenses</h4>
                        <ul>
                            {member.expenses.map((expense, index) => (
                                <li key={index}>
                                    ${expense.toFixed(2)}
                                    <button className="remove-expense-btn icon-button" onClick={() => onRemoveExpense(member.name, index)}><XIcon /></button>
                                </li>
                            ))}
                        </ul>
                        <div className="input-group input-group-responsive">
                            <div className="input-with-prefix">
                                <span>$</span>
                                <input
                                    type="number"
                                    inputmode="decimal"
                                    value={newExpense}
                                    onChange={e => setNewExpense(e.target.value)}
                                    onKeyDown={handleExpenseKeyDown}
                                    placeholder="Expense amount"
                                />
                            </div>
                            <button onClick={handleAddExpense} className="icon-button"><PlusIcon /></button>
                        </div>
                    </div>

                    {calculated && (
                        <div>
                            <p className="final-owed">Owed: <span>${calculated.finalOwed.toFixed(2)}</span></p>
                            <button className="details-btn" onClick={() => setIsDetailsCollapsed(!isDetailsCollapsed)}>
                                Details <ChevronIcon isCollapsed={isDetailsCollapsed} />
                            </button>
                            {!isDetailsCollapsed && (
                                <div className="calculations">
                                    <p>Subtotal: <span>${calculated.subtotal.toFixed(2)}</span></p>
                                    <p>Tax: <span>${calculated.tax.toFixed(2)}</span></p>
                                    <p>Tip: <span>${calculated.tip.toFixed(2)}</span></p>
                                    <p>Pre-Winnings: <span>${calculated.preWinningsTotal.toFixed(2)}</span></p>
                                    <p>Winnings Share: <span>-${calculated.winningsShare.toFixed(2)}</span></p>
                                </div>
                            )}
                        </div>
                    )}
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
